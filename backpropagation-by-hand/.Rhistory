#Unnormalised
N = 10000
U = runif(N, 0, 1)
X = 1-sqrt(U)
I.hat = sum(1+X)/sum(1/(1-X))
N = 100000000
U = runif(N, 0, 1)
X = 1-sqrt(U)
I.hat = sum(1+X)/sum(1/(1-X))
u=runif(N)
x=1-sqrt(1-u)
mean(1+x)/mean(1/(1-x))
?rgamma
?gamma
K = 0.1068458
imp.sampler = function(N){
X = rgamma(N, 4, 2)
I.hat = gamma(4)/2^4 * 1/K * mean(exp(-X^2/2))
w = gamma(4)/2^4 * 1/K * 1/X * exp(-X^2/2)
return(list(I = I.hat, w = w))
}
K = 0.1068458
imp.sampler = function(N){
X = rgamma(N, 4, 2)
I.hat = gamma(4)/2^4 * 1/K * mean(exp(-X^2/2))
w = gamma(4)/2^4 * 1/K * 1/X * exp(-X^2/2)
return(list(I = I.hat, w = w))
}
N=100
sample = imp.sampler(N)
I.hat = sample$I
w = sample$w
hist(w)
norm.sampler = function(N){
X = rnorm(N, 1, sqrt(1/4))
f = 1/K * X^2 * exp(-X^2/2 -2*x)
h = X
g = 1/sqrt(pi/2) * exp(-2*(X-1)^2)
w = f/g
I.hat = mean(w*h)
return(list(I = I.hat, w = w))
}
samplen = norm.sampler(N)
norm.sampler = function(N){
X = rnorm(N, 1, sqrt(1/4))
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
g = 1/sqrt(pi/2) * exp(-2*(X-1)^2)
w = f/g
I.hat = mean(w*h)
return(list(I = I.hat, w = w))
}
samplen = norm.sampler(N)
I.hatn = samplen$I
w = samplen$w
hist(w)
norm.sampler = function(N){
X = rnorm(N, 1, sqrt(1/4))
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
g = 1/sqrt(pi/2) * exp(-2*(X-1)^2)
w = f/g
I.hat = mean(w*h)
return(list(I = I.hat, w = w))
}
samplen = norm.sampler(N)
I.hatn = samplen$I
w = samplen$w
hist(w)
norm.sampler = function(N){
X = rnorm(N, 1, sqrt(1/4))
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
g = 1/sqrt(pi/2) * exp(-2*(X-1)^2)
w = f/g
I.hat = mean(w*h)
return(list(I = I.hat, w = w))
}
samplen = norm.sampler(N)
I.hatn = samplen$I
w = samplen$w
hist(w)
N=100
sample = gamma.sampler(N)
K = 0.1068458
gamma.sampler = function(N){
X = rgamma(N, 4, 2)
I.hat = gamma(4)/2^4 * 1/K * mean(exp(-X^2/2))
w = gamma(4)/2^4 * 1/K * 1/X * exp(-X^2/2)
return(list(I = I.hat, w = w))
}
N=100
sample = gamma.sampler(N)
I.hat = sample$I
w = sample$w
hist(w)
norm.sampler = function(N){
X = rnorm(N, 1, sqrt(1/4))
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
g = 1/sqrt(pi/2) * exp(-2*(X-1)^2)
w = f/g
I.hat = mean(w*h)
return(list(I = I.hat, w = w))
}
sample.n = norm.sampler(N)
I.hatn = sample.n$I
w = sample.n$w
hist(w)
norm.sampler = function(N){
X = rnorm(N, 1, sqrt(1/4))
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
g = 1/sqrt(pi/2) * exp(-2*(X-1)^2)
w = f/g
ind = which(X<0, arr.ind=TRUE)
w[ind] = 0
I.hat = mean(w*h)
return(list(I = I.hat, w = w))
}
sample.n = norm.sampler(N)
I.hatn = sample.n$I
w = sample.n$w
hist(w)
plot(X, h*f)
#plot integrand
X = seq(0, 100, length.out = 1000)
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
plot(X, h*f)
X = seq(0, 100, length.out = 1000)
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
plot(X, h*f, type="l")
X = seq(0, 10, length.out = 100)
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
plot(X, h*f, type="l")
X = seq(0, 4, length.out = 100)
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
plot(X, h*f, type="l")
?dgamma
points(X, dgamma(X, 4, 2), type="l", col="red")
points(X, dnorm(X, 0, sqrt(1/4)), type="l", col="blue")
plot(X, h*f, type="l")
points(X, dgamma(X, 4, 2), type="l", col="red")
points(X, dnorm(X, 1, sqrt(1/4)), type="l", col="blue")
plot(X, h*f, type="l", ylim=c(0,1))
plot(X, h*f, type="l", ylim=c(0,1))
points(X, dgamma(X, 4, 2), type="l", col="red")
points(X, dnorm(X, 1, sqrt(1/4)), type="l", col="blue")
plot(X, h*f, type="l", ylim=c(0,0.8))
points(X, dgamma(X, 4, 2), type="l", col="red")
points(X, dnorm(X, 1, sqrt(1/4)), type="l", col="blue")
#unnormalised sampler with normal
unnorm.sampler = function(N){
X = rnorm(N, 1, sqrt(1/4))
f1 = X^2 * exp(-X^2/2 -2*X)
h = X
g = 1/sqrt(pi/2) * exp(-2*(X-1)^2)
w = f1/g
ind = which(X<0, arr.ind=TRUE)
w[ind] = 0
I.hat = mean(w*h)/mean(w)
return(list(I = I.hat, w = w))
}
sample.unn = unnorm.sampler(N)
I.hatn = sample.unn$I
#gamma sampler
K = 0.1068458
gamma.sampler = function(N){
X = rgamma(N, 4, 2)
I.hat = gamma(4)/2^4 * 1/K * mean(exp(-X^2/2))
w = gamma(4)/2^4 * 1/K * 1/X * exp(-X^2/2)
return(list(I = I.hat, w = w))
}
N=100
sample = gamma.sampler(N)
I.hat = sample$I
w = sample$w
hist(w)
#normal sampler
norm.sampler = function(N){
X = rnorm(N, 1, sqrt(1/4))
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
g = 1/sqrt(pi/2) * exp(-2*(X-1)^2)
w = f/g
ind = which(X<0, arr.ind=TRUE)
w[ind] = 0
I.hat = mean(w*h)
return(list(I = I.hat, w = w))
}
sample.n = norm.sampler(N)
I.hatn = sample.n$I
w = sample.n$w
hist(w)
#plot integrand
X = seq(0, 4, length.out = 100)
f = 1/K * X^2 * exp(-X^2/2 -2*X)
h = X
plot(X, h*f, type="l", ylim=c(0,0.8))
points(X, dgamma(X, 4, 2), type="l", col="red")
points(X, dnorm(X, 1, sqrt(1/4)), type="l", col="blue")
#unnormalised sampler with normal
unnorm.sampler = function(N){
X = rnorm(N, 1, sqrt(1/4))
f1 = X^2 * exp(-X^2/2 -2*X)
h = X
g = 1/sqrt(pi/2) * exp(-2*(X-1)^2)
w = f1/g
ind = which(X<0, arr.ind=TRUE)
w[ind] = 0
I.hat = mean(w*h)/mean(w)
return(list(I = I.hat, w = w))
}
sample.unn = unnorm.sampler(N)
I.hatunn = sample.unn$I
x = c(0.02, -0.18, -1.37, -0.60, 0.29)
post = function(theta){
return(exp(sum(-(x-theta)^2/2))/pi*(1+theta^2))
}
x = c(0.02, -0.18, -1.37, -0.60, 0.29)
post = function(theta){
return(exp(sum(-(x-theta)^2/2))/pi*(1+theta^2))
}
theta = seq(-100, 100, length.out = 1000)
plot(theta, theta*post(theta), type="l")
x = c(0.02, -0.18, -1.37, -0.60, 0.29)
post = function(theta){
return(exp(sum(-(x-theta)^2/2))/pi*(1+theta^2))
}
theta = seq(-4, 4, length.out = 1000)
plot(theta, theta*post(theta), type="l")
x = c(0.02, -0.18, -1.37, -0.60, 0.29)
post = function(theta){
return(exp(sum(-(x-theta)^2/2))*pi*(1+theta^2))
}
theta = seq(-4, 4, length.out = 1000)
plot(theta, theta*post(theta), type="l")
x = c(0.02, -0.18, -1.37, -0.60, 0.29)
post = function(theta){
return(exp(sum(-((x-theta)^2)/2))*pi*(1+theta^2))
}
theta = seq(-4, 4, length.out = 1000)
plot(theta, theta*post(theta), type="l")
x = c(0.02, -0.18, -1.37, -0.60, 0.29)
post = function(theta){
return(abs(exp(sum(-((x-theta)^2)/2))*pi*(1+theta^2)))
}
theta = seq(-4, 4, length.out = 1000)
plot(theta, theta*post(theta), type="l")
post = function(theta){
x = c(0.02, -0.18, -1.37, -0.60, 0.29)
return(abs(exp(sum(-((x-theta)^2)/2))*pi*(1+theta^2)))
}
theta = seq(-4, 4, length.out = 1000)
plot(theta, theta*post(theta), type="l")
setwd("~/Documents/Uni/Year 4/Dissertation/tetris-diss/tetris-diss/backpropagation-by-hand")
data = read.csv("log.csv")
convert_string_to_matrix <- function(input_string, nrow, ncol) {
clean_string <- gsub("\n", " ", input_string)
clean_string <- gsub("\\(", " ", clean_string)
clean_string <- gsub("\\)", " ", clean_string)
clean_string <- gsub("\\[", " ", clean_string)
clean_string <- gsub("\\]", " ", clean_string)
clean_string <- gsub("array", " ", clean_string)
clean_string <- gsub("dtype=float32", " ", clean_string)
clean_string <- gsub("\\,", " ", clean_string)
clean_string <- gsub("\\s+", " ", clean_string)
clean_string <- sub("^\\s+", "", clean_string)
print(clean_string)
number_vector <- as.numeric(strsplit(clean_string, " ")[[1]])
matrix_result <- matrix(number_vector, nrow = nrow, ncol = ncol, byrow = TRUE)
return(matrix_result)
}
convert_gridstring_to_vector = function(str){
clean_str <- gsub("\\[|\\]", "", str)
clean_str <- gsub("\\.", "", clean_str)
number_vector <- as.numeric(strsplit(clean_str, " ")[[1]])
return(number_vector)
}
softmax = function(z){
n = length(z)
v = matrix(NA, 1, n)
for (i in 1:n){
v[i] = exp(z[i])/sum(exp(z))
}
return(v)
}
#Check the forward pass is correct
weights.01 = convert_string_to_matrix(data$weights.layer.1[1], 20, 2)
weights.02 = convert_string_to_matrix(data$weights.layer.2[1], 2, 2)
weights.03 = convert_string_to_matrix(data$weights.layer.3[1], 2, 19)
grid = convert_gridstring_to_vector(data$grid[2])
layer1 = grid%*%weights.01
layer2 = layer1%*%weights.02
layer3 = layer2%*%weights.03
output.probs = softmax(layer3)
action.index = which.max(output.probs)
actions = c("h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9",
"v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v0")
action = actions[action.index]
#Then we know the loss
loss = data$loss[2]
View(weights.01)
View(weights.02)
View(weights.03)
weights.01 = convert_string_to_matrix(data$weights.layer.1[2], 20, 2)
weights.02 = convert_string_to_matrix(data$weights.layer.2[2], 2, 2)
weights.03 = convert_string_to_matrix(data$weights.layer.3[2], 2, 19)
View(weights.01)
View(weights.02)
View(weights.03)
weights.01 = convert_string_to_matrix(data$weights.layer.1[1], 20, 2)
weights.02 = convert_string_to_matrix(data$weights.layer.2[1], 2, 2)
weights.03 = convert_string_to_matrix(data$weights.layer.3[1], 2, 19)
weights2.01 = convert_string_to_matrix(data$weights.layer.1[2], 20, 2)
weights2.02 = convert_string_to_matrix(data$weights.layer.2[2], 2, 2)
weights2.03 = convert_string_to_matrix(data$weights.layer.3[2], 2, 19)
View(weights.01)
View(weights2.01)
View(weights.02)
View(weights2.02)
View(weights.03)
View(weights2.03)
weights3.01 = convert_string_to_matrix(data$weights.layer.1[3], 20, 2)
weights3.02 = convert_string_to_matrix(data$weights.layer.2[3], 2, 2)
weights3.03 = convert_string_to_matrix(data$weights.layer.3[3], 2, 19)
View(weights2.01)
View(weights3.01)
View(weights2.02)
View(weights3.02)
View(weights2.03)
View(weights3.03)
which(weights3.01 != weights.01)
weights3.01 = convert_string_to_matrix(data$weights.layer.1[14], 20, 2)
weights3.02 = convert_string_to_matrix(data$weights.layer.2[14], 2, 2)
weights3.03 = convert_string_to_matrix(data$weights.layer.3[14], 2, 19)
which(weights3.01 != weights.01)
which(weights3.02 != weights.02)
which(weights3.03 != weights.03)
data = read.csv("log.csv")
convert_string_to_matrix <- function(input_string, nrow, ncol) {
clean_string <- gsub("\n", " ", input_string)
clean_string <- gsub("\\(", " ", clean_string)
clean_string <- gsub("\\)", " ", clean_string)
clean_string <- gsub("\\[", " ", clean_string)
clean_string <- gsub("\\]", " ", clean_string)
clean_string <- gsub("array", " ", clean_string)
clean_string <- gsub("dtype=float32", " ", clean_string)
clean_string <- gsub("\\,", " ", clean_string)
clean_string <- gsub("\\s+", " ", clean_string)
clean_string <- sub("^\\s+", "", clean_string)
print(clean_string)
number_vector <- as.numeric(strsplit(clean_string, " ")[[1]])
matrix_result <- matrix(number_vector, nrow = nrow, ncol = ncol, byrow = TRUE)
return(matrix_result)
}
convert_gridstring_to_vector = function(str){
clean_str <- gsub("\\[|\\]", "", str)
clean_str <- gsub("\\.", "", clean_str)
number_vector <- as.numeric(strsplit(clean_str, " ")[[1]])
return(number_vector)
}
softmax = function(z){
n = length(z)
v = matrix(NA, 1, n)
for (i in 1:n){
v[i] = exp(z[i])/sum(exp(z))
}
return(v)
}
#Check the forward pass is correct
weights.01 = convert_string_to_matrix(data$weights.layer.1[1], 20, 2)
weights.02 = convert_string_to_matrix(data$weights.layer.2[1], 2, 2)
weights.03 = convert_string_to_matrix(data$weights.layer.3[1], 2, 19)
grid = convert_gridstring_to_vector(data$grid[2])
layer1 = grid%*%weights.01
layer2 = layer1%*%weights.02
layer3 = layer2%*%weights.03
output.probs = softmax(layer3)
action.index = which.max(output.probs)
actions = c("h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9",
"v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v0")
action = actions[action.index]
#Then we know the loss
loss = data$loss[2]
weights3.01 = convert_string_to_matrix(data$weights.layer.1[14], 20, 2)
weights3.02 = convert_string_to_matrix(data$weights.layer.2[14], 2, 2)
weights3.03 = convert_string_to_matrix(data$weights.layer.3[14], 2, 19)
which(weights3.01 != weights.01)
which(weights3.02 != weights.02)
which(weights3.03 != weights.03)
weights3.01 = convert_string_to_matrix(data$weights.layer.1[3], 20, 2)
weights3.02 = convert_string_to_matrix(data$weights.layer.2[3], 2, 2)
weights3.03 = convert_string_to_matrix(data$weights.layer.3[3], 2, 19)
which(weights3.01 != weights.01)
which(weights3.02 != weights.02)
which(weights3.03 != weights.03)
View(weights.01)
#Check the forward pass is correct
weights.01 = convert_string_to_matrix(data$weights.layer.1[2], 20, 2)
weights.02 = convert_string_to_matrix(data$weights.layer.2[2], 2, 2)
weights.03 = convert_string_to_matrix(data$weights.layer.3[2], 2, 19)
grid = convert_gridstring_to_vector(data$grid[2])
layer1 = grid%*%weights.01
layer2 = layer1%*%weights.02
layer3 = layer2%*%weights.03
output.probs = softmax(layer3)
action.index = which.max(output.probs)
actions = c("h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9",
"v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v0")
action = actions[action.index]
grid
which(grid=1, arr.ind = TRUE)
which(grid==1, arr.ind = TRUE)
weights.01[15]
weights.01[16]
weights.01[15,1]
weights.01[15,2]
weights.01[16,1]
weights.01[16,2]
View(weights.02)
layer2 = layer1%*%t(weights.02)
layer2 = layer1%*%weights.02
layer2 = 1/(1+exp(-layer2))
layer3 = layer2%*%weights.03
output.probs = softmax(layer3)
action.index = which.max(output.probs)
actions = c("h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9",
"v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v0")
action = actions[action.index]
layer1 = which(layer1>0)
?relu
ind1 = which(layer1>0)
weights.03[1,1]
weights.03[1,2]
weights.03[6,1]
weights.03[1,6]
View(weights.03)
?pmax
layer1 = grid%*%weights.01
layer1 = pmax(0, layer1)
layer3 = layer2%*%weights.03
View(layer3)
output.probs = softmax(layer3)
View(output.probs)
View(weights3.01)
View(weights3.03)
setwd("~/Documents/Uni/Year 4/Dissertation/tetris-diss/logs")
data = read.csv("log.csv")
max(data$game.no.)
plot(data$game.no., data$score)
setwd("~/Documents/Uni/Year 4/Dissertation/tetris-diss/tetris-diss/backpropagation-by-hand")
data = read.csv("log.csv")
convert_string_to_matrix <- function(input_string, nrow, ncol) {
clean_string <- gsub("\n", " ", input_string)
clean_string <- gsub("\\(", " ", clean_string)
clean_string <- gsub("\\)", " ", clean_string)
clean_string <- gsub("\\[", " ", clean_string)
clean_string <- gsub("\\]", " ", clean_string)
clean_string <- gsub("array", " ", clean_string)
clean_string <- gsub("dtype=float32", " ", clean_string)
clean_string <- gsub("\\,", " ", clean_string)
clean_string <- gsub("\\s+", " ", clean_string)
clean_string <- sub("^\\s+", "", clean_string)
print(clean_string)
number_vector <- as.numeric(strsplit(clean_string, " ")[[1]])
matrix_result <- matrix(number_vector, nrow = nrow, ncol = ncol, byrow = TRUE)
return(matrix_result)
}
convert_gridstring_to_vector = function(str){
clean_str <- gsub("\\[|\\]", "", str)
clean_str <- gsub("\\.", "", clean_str)
number_vector <- as.numeric(strsplit(clean_str, " ")[[1]])
return(number_vector)
}
softmax = function(z){
n = length(z)
v = matrix(NA, 1, n)
for (i in 1:n){
v[i] = exp(z[i])/sum(exp(z))
}
return(v)
}
#Check the forward pass is correct
weights.01 = convert_string_to_matrix(data$weights.layer.1[2], 20, 2)
weights.02 = convert_string_to_matrix(data$weights.layer.2[2], 2, 2)
weights.03 = convert_string_to_matrix(data$weights.layer.3[2], 2, 19)
grid = convert_gridstring_to_vector(data$grid[2])
layer1 = grid%*%weights.01
layer1 = pmax(0, layer1)
layer2 = layer1%*%weights.02
layer2 = 1/(1+exp(-layer2))
layer3 = layer2%*%weights.03
output.probs = softmax(layer3)
action.index = which.max(output.probs)
actions = c("h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9",
"v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v0")
action = actions[action.index]
#Then we know the loss
loss = data$loss[2]
weights3.01 = convert_string_to_matrix(data$weights.layer.1[3], 20, 2)
weights3.02 = convert_string_to_matrix(data$weights.layer.2[3], 2, 2)
weights3.03 = convert_string_to_matrix(data$weights.layer.3[3], 2, 19)
which(weights3.01 != weights.01)
which(weights3.02 != weights.02)
which(weights3.03 != weights.03)
View(weights3.01)
View(weights.01)
