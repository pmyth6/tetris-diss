z = outer(x, y, func)
contour(x, y, z)
par(mfrow=c(1,1))
par(mar = c(1, 1, 1, 1))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, func)
contour(x, y, z)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(S$T, S$PH)
func = function(theta, phi){
return(10*log(phi) - (1+5*phi)*theta^2 + 40*theta*phi - 81*phi)
}
alpha = function(theta, theta_y, phi, phi_y){
a = func(theta, phi)
b = func(theta_y, phi_y)
return(min(1, b/a))
}
MH = function(theta, phi, tvar, phvar, n){
THETA = 0
PHI = 0
a_T = 0
a_PH = 0
count = 0
THETA[1] = theta
PHI[1] = phi
for (i in 2:n){
count = count+1
theta_y = rnorm(1, theta, sqrt(tvar))
phi_y = rnorm(1, phi, sqrt(phvar))
if (phi_y >0){
u = runif(1, 0, 1)
logalpha = alpha(theta, theta_y, phi, phi_y)
if (log(u) < logalpha){
theta = theta_y
phi = phi_y
a_T = a_T +1
a_PH = a_PH +1
}
}
THETA[i] = theta
PHI[i] = phi
}
return(list(T = THETA, PH = PHI, aT = a_T/count, aPH = a_PH/count))
}
S = MH(1, 2, 0.25, 1, 10000)
par(mfrow=c(3,2))
par(mar = c(2, 2, 2, 2))
ts.plot(S$T)
ts.plot(S$PH)
hist(S$T)
hist(S$PH)
acf(S$T)
acf(S$PH)
par(mfrow=c(1,1))
par(mar = c(1, 1, 1, 1))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, func)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(S$T, S$PH)
par(mfrow=c(1,1))
par(mar = c(2, 2, 2, 2))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, func)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(S$T, S$PH)
par(mfrow=c(1,1))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, func)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(S$T, S$PH)
par(mfrow=c(1,1))
par(mar = c(3, 3, 3, 3))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, func)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(S$T, S$PH)
par(mfrow=c(1,1))
par(mar = c(5.1, 4.1, 4.1, 2.1))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, func)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(S$T, S$PH)
log_post = function(theta, phi){
return(10*log(phi) - (1+5*phi)*theta^2 + 40*theta*phi - 81*phi)
}
post = function(theta, phi){
return(phi^10 * exp(-(1+5*phi)*theta^2 + 40*theta*phi - 81*phi))
}
log_post = function(theta, phi){
return(10*log(phi) - (1+5*phi)*theta^2 + 40*theta*phi - 81*phi)
}
alpha_t = function(theta, theta_p, phi, var_theta){
return(min(1, (post(theta_p, phi)*dnorm(theta,theta,sqrt(var_theta)))/(post(theta, phi)*dnorm(theta_p,theta,sqrt(var_theta)))))
}
alpha_p = function(phi, phi_p, theta, var_phi){
return(min(1, (post(theta, phi_p)*dnorm(phi,phi,sqrt(var_phi)))/(post(theta, phi)*dnorm(phi_p,phi,sqrt(var_phi)))))
}
MH = function(n, theta, var_theta, phi, var_phi){
THETA = matrix(NA, n, 1)
PHI = matrix(NA, n, 1)
THETA[1] = theta
PHI[1] = phi
for (i in 2:n){
theta_p = rnorm(1, theta, sqrt(var_theta))
if (runif(1,0,1) < alpha_t(theta, theta_p, phi, var_theta)){
theta = theta_p
}
phi_p = rnorm(1, phi, sqrt(var_phi))
if ((runif(1,0,1) < alpha_p(phi, phi_p, theta, var_phi)) & (phi > 0)){
phi = phi_p
}
THETA[i] = theta
PHI[i] = phi
}
return(list(TH = THETA, PH = PHI))
}
theta = 1
var_theta = 0.25
phi = 2
var_phi = 1
MHs = MH(500, theta, var_theta, phi, var_phi)
S = MH(1, 2, 0.25, 1, 10000)
par(mfrow=c(3,2))
par(mar = c(2, 2, 2, 2))
ts.plot(S$T)
ts.plot(S$PH)
hist(S$T)
hist(S$PH)
acf(S$T)
func = function(theta, phi){
return(10*log(phi) - (1+5*phi)*theta^2 + 40*theta*phi - 81*phi)
}
alpha = function(theta, theta_y, phi, phi_y){
a = func(theta, phi)
b = func(theta_y, phi_y)
return(min(1, b/a))
}
MH = function(theta, phi, tvar, phvar, n){
THETA = 0
PHI = 0
a_T = 0
a_PH = 0
count = 0
THETA[1] = theta
PHI[1] = phi
for (i in 2:n){
count = count+1
theta_y = rnorm(1, theta, sqrt(tvar))
phi_y = rnorm(1, phi, sqrt(phvar))
if (phi_y >0){
u = runif(1, 0, 1)
logalpha = alpha(theta, theta_y, phi, phi_y)
if (log(u) < logalpha){
theta = theta_y
phi = phi_y
a_T = a_T +1
a_PH = a_PH +1
}
}
THETA[i] = theta
PHI[i] = phi
}
return(list(T = THETA, PH = PHI, aT = a_T/count, aPH = a_PH/count))
}
S = MH(1, 2, 0.25, 1, 10000)
par(mfrow=c(3,2))
par(mar = c(2, 2, 2, 2))
ts.plot(S$T)
ts.plot(S$PH)
hist(S$T)
hist(S$PH)
acf(S$T)
acf(S$PH)
func = function(theta, phi){
return(10*log(phi) - (1+5*phi)*theta^2 + 40*theta*phi - 81*phi)
}
alpha = function(theta, theta_y, phi, phi_y){
a = func(theta, phi)
b = func(theta_y, phi_y)
return(min(0, b-a))
}
MH = function(theta, phi, tvar, phvar, n){
THETA = 0
PHI = 0
a_T = 0
a_PH = 0
count = 0
THETA[1] = theta
PHI[1] = phi
for (i in 2:n){
count = count+1
theta_y = rnorm(1, theta, sqrt(tvar))
phi_y = rnorm(1, phi, sqrt(phvar))
if (phi_y >0){
u = runif(1, 0, 1)
logalpha = alpha(theta, theta_y, phi, phi_y)
if (log(u) < logalpha){
theta = theta_y
phi = phi_y
a_T = a_T +1
a_PH = a_PH +1
}
}
THETA[i] = theta
PHI[i] = phi
}
return(list(T = THETA, PH = PHI, aT = a_T/count, aPH = a_PH/count))
}
S = MH(1, 2, 0.25, 1, 10000)
par(mfrow=c(3,2))
par(mar = c(2, 2, 2, 2))
ts.plot(S$T)
ts.plot(S$PH)
hist(S$T)
hist(S$PH)
acf(S$T)
acf(S$PH)
par(mfrow=c(1,1))
par(mar = c(5.1, 4.1, 4.1, 2.1))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, func)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(S$T, S$PH)
post = function(theta, phi){
return(phi^10 * exp(-(1+5*phi)*theta^2 + 40*theta*phi - 81*phi))
}
log_post = function(theta, phi){
return(10*log(phi) - (1+5*phi)*theta^2 + 40*theta*phi - 81*phi)
}
alpha_t = function(theta, theta_p, phi, var_theta){
return(min(1, (post(theta_p, phi)*dnorm(theta,theta,sqrt(var_theta)))/(post(theta, phi)*dnorm(theta_p,theta,sqrt(var_theta)))))
}
alpha_p = function(phi, phi_p, theta, var_phi){
return(min(1, (post(theta, phi_p)*dnorm(phi,phi,sqrt(var_phi)))/(post(theta, phi)*dnorm(phi_p,phi,sqrt(var_phi)))))
}
MH = function(n, theta, var_theta, phi, var_phi){
THETA = matrix(NA, n, 1)
PHI = matrix(NA, n, 1)
THETA[1] = theta
PHI[1] = phi
for (i in 2:n){
theta_p = rnorm(1, theta, sqrt(var_theta))
if (runif(1,0,1) < alpha_t(theta, theta_p, phi, var_theta)){
theta = theta_p
}
phi_p = rnorm(1, phi, sqrt(var_phi))
if ((runif(1,0,1) < alpha_p(phi, phi_p, theta, var_phi)) & (phi > 0)){
phi = phi_p
}
THETA[i] = theta
PHI[i] = phi
}
return(list(TH = THETA, PH = PHI))
}
theta = 1
var_theta = 0.25
phi = 2
var_phi = 1
MHs = MH(500, theta, var_theta, phi, var_phi)
par(mfrow=c(3,2))
par(mar = c(2, 2, 2, 2))
ts.plot(MHs$TH)
ts.plot(MHs$PH)
hist(MHs$TH)
hist(MHs$PH)
acf(MHs$TH)
acf(MHs$PH)
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, log_post)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(MHs$TH, MHs$PH)
post = function(theta, phi){
return(phi^10 * exp(-(1+5*phi)*theta^2 + 40*theta*phi - 81*phi))
}
log_post = function(theta, phi){
return(10*log(phi) - (1+5*phi)*theta^2 + 40*theta*phi - 81*phi)
}
alpha_t = function(theta, theta_p, phi, var_theta){
return(min(1, (post(theta_p, phi)*dnorm(theta,theta,sqrt(var_theta)))/(post(theta, phi)*dnorm(theta_p,theta,sqrt(var_theta)))))
}
alpha_p = function(phi, phi_p, theta, var_phi){
return(min(1, (post(theta, phi_p)*dnorm(phi,phi,sqrt(var_phi)))/(post(theta, phi)*dnorm(phi_p,phi,sqrt(var_phi)))))
}
MH = function(n, theta, var_theta, phi, var_phi){
THETA = matrix(NA, n, 1)
PHI = matrix(NA, n, 1)
THETA[1] = theta
PHI[1] = phi
for (i in 2:n){
theta_p = rnorm(1, theta, sqrt(var_theta))
if (runif(1,0,1) < alpha_t(theta, theta_p, phi, var_theta)){
theta = theta_p
}
phi_p = rnorm(1, phi, sqrt(var_phi))
if ((runif(1,0,1) < alpha_p(phi, phi_p, theta, var_phi)) & (phi > 0)){
phi = phi_p
}
THETA[i] = theta
PHI[i] = phi
}
return(list(TH = THETA, PH = PHI))
}
theta = 1
var_theta = 0.25
phi = 2
var_phi = 1
MHs = MH(500, theta, var_theta, phi, var_phi)
par(mfrow=c(1,1))
par(mar = c(5.1, 4.1, 4.1, 2.1))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, log_post)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(MHs$TH, MHs$PH)
post = function(theta, phi){
return(phi^10 * exp(-(1+5*phi)*theta^2 + 40*theta*phi - 81*phi))
}
log_post = function(theta, phi){
return(10*log(phi) - (1+5*phi)*theta^2 + 40*theta*phi - 81*phi)
}
alpha_t = function(theta, theta_p, phi, var_theta){
a = log_post(theta_p, phi)+log(dnorm(theta,theta,sqrt(var_theta)))
b = log_post(theta, phi)+log(dnorm(theta_p,theta,sqrt(var_theta)))
return(min(0, a-b))
}
alpha_p = function(phi, phi_p, theta, var_phi){
a = log_post(theta, phi_p)+log(dnorm(phi,phi,sqrt(var_phi)))
b = log_post(theta, phi)+log(dnorm(phi_p,phi,sqrt(var_phi)))
return(min(1, a-b))
}
MH = function(n, theta, var_theta, phi, var_phi){
THETA = matrix(NA, n, 1)
PHI = matrix(NA, n, 1)
THETA[1] = theta
PHI[1] = phi
for (i in 2:n){
theta_p = rnorm(1, theta, sqrt(var_theta))
if (log(runif(1,0,1)) < alpha_t(theta, theta_p, phi, var_theta)){
theta = theta_p
}
phi_p = rnorm(1, phi, sqrt(var_phi))
if ((log(runif(1,0,1)) < alpha_p(phi, phi_p, theta, var_phi)) & (phi > 0)){
phi = phi_p
}
THETA[i] = theta
PHI[i] = phi
}
return(list(TH = THETA, PH = PHI))
}
theta = 1
var_theta = 0.25
phi = 2
var_phi = 1
MHs = MH(500, theta, var_theta, phi, var_phi)
par(mfrow=c(3,2))
par(mar = c(2, 2, 2, 2))
ts.plot(MHs$TH)
ts.plot(MHs$PH)
hist(MHs$TH)
hist(MHs$PH)
acf(MHs$TH)
acf(MHs$PH)
par(mfrow=c(1,1))
par(mar = c(5.1, 4.1, 4.1, 2.1))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, log_post)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(MHs$TH, MHs$PH)
post = function(theta, phi){
return(phi^10 * exp(-(1+5*phi)*theta^2 + 40*theta*phi - 81*phi))
}
log_post = function(theta, phi){
return(10*log(phi) - (1+5*phi)*theta^2 + 40*theta*phi - 81*phi)
}
alpha_t = function(theta, theta_p, phi, var_theta){
a = log_post(theta_p, phi)+log(dnorm(theta,theta,sqrt(var_theta)))
b = log_post(theta, phi)+log(dnorm(theta_p,theta,sqrt(var_theta)))
return(min(0, a-b))
}
alpha_p = function(phi, phi_p, theta, var_phi){
a = log_post(theta, phi_p)+log(dnorm(phi,phi,sqrt(var_phi)))
b = log_post(theta, phi)+log(dnorm(phi_p,phi,sqrt(var_phi)))
return(min(1, a-b))
}
MH = function(n, theta, var_theta){
THETA = matrix(NA, n, 1)
PHI = matrix(NA, n, 1)
THETA[1] = theta
PHI[1] = rgamma(1, 11, 1/(5*theta^2 -40*theta +81))
for (i in 2:n){
theta_p = rnorm(1, theta, sqrt(var_theta))
if (log(runif(1,0,1)) < alpha_t(theta, theta_p, phi, var_theta)){
theta = theta_p
}
phi = rgamma(1, 11, 1/(5*theta^2 -40*theta +81))
THETA[i] = theta
PHI[i] = phi
}
return(list(TH = THETA, PH = PHI))
}
theta = 1
var_theta = 0.25
MHs = MH(500, theta, var_theta)
par(mfrow=c(3,2))
par(mar = c(2, 2, 2, 2))
ts.plot(MHs$TH)
ts.plot(MHs$PH)
hist(MHs$TH)
hist(MHs$PH)
acf(MHs$TH)
acf(MHs$PH)
par(mfrow=c(1,1))
par(mar = c(5.1, 4.1, 4.1, 2.1))
x = seq(0, 8, length.out = 1000)
y = seq(0, 20, length.out = 1000)
z = outer(x, y, log_post)
contour(x, y, z, levels=c(-10,-20,-40,-60,-80))
points(MHs$TH, MHs$PH)
setwd("~/Documents/Uni/Year 4/Dissertation/tetris-diss/tetris-diss/scenario-model")
read.csv("log.csv")
data = read.csv("log.csv")
data$loss <- gsub("\\[|\\]", "", data$loss)
data$loss = as.double(data$loss)
data = read.csv("log.csv")
data$loss <- gsub("\\[|\\]", "", data$loss)
data$loss = as.numeric(data$loss)
data$loss[2]
n = length(data$probability)
plot(seq(1,n,length.out=n), data$loss)
plot(seq(1,n,length.out=n), data$loss, col=data$move)
moves = unique(data$move)
install.packages("randomcoloR")
library(randomcoloR)
library(randomcoloR)
data = read.csv("log.csv")
data$loss <- gsub("\\[|\\]", "", data$loss)
data$loss = as.numeric(data$loss)
n = length(data$probability)
moves = unique(data$move)
colors <- distinctColorPalette(length(moves))
names(colors) <- moves
# View assigned colors
print(colors)
moves = unique(data$move)
colors <- distinctColorPalette(length(moves))
names(colors) <- moves
ggplot(data, aes(x=move_no, y=loss, fill=move))+
geom_point(size=4)+
scale_color_manual(values=colors)+
labs(title="Loss per move", x="Move number", y="loss")
library(randomcoloR)
library(ggplot2)
data = read.csv("log.csv")
data$loss <- gsub("\\[|\\]", "", data$loss)
data$loss = as.numeric(data$loss)
n = length(data$probability)
moves = unique(data$move)
colors <- distinctColorPalette(length(moves))
names(colors) <- moves
ggplot(data, aes(x=move_no, y=loss, fill=move))+
geom_point(size=4)+
scale_color_manual(values=colors)+
labs(title="Loss per move", x="Move number", y="loss")
ggplot(data, aes(x=move_no, y=loss, fill=move))+
geom_point(size=1)+
scale_color_manual(values=colors)+
labs(title="Loss per move", x="Move number", y="loss")
ggplot(data, aes(x=move_no, y=loss, fill=move))+
geom_point(size=1)+
labs(title="Loss per move", x="Move number", y="loss")
ggplot(data, aes(x=move_no, y=loss, fill=moves))+
geom_point(size=1)+
labs(title="Loss per move", x="Move number", y="loss")
ggplot(data, aes(x=move_no, y=loss, fill=colors))+
geom_point(size=1)+
labs(title="Loss per move", x="Move number", y="loss")
ggplot(data, aes(x=move_no, y=loss, color=move))+
geom_point(size=1)+
labs(title="Loss per move", x="Move number", y="loss")
ggplot(data, aes(x=move_no, y=loss, color=move))+
geom_point(size=1)+
theme_minimal()+
labs(x="Move Number", y="Loss")+
theme(
text = element_text(size = 16),  # Increase all text size
axis.title = element_text(size = 18),  # Increase axis titles
axis.text = element_text(size = 14),  # Increase axis labels
legend.title = element_text(size = 16),  # Increase legend title size
legend.text = element_text(size = 14)  # Increase legend text size
)
data$probability <- gsub("\\[|\\]", "", data$probability)
data$probability = as.numeric(data$probability)
ggplot(data, aes(x=move_no, y=probability, color=move))+
geom_point(size=1)+
theme_minimal()+
labs(x="Move Number", y="Probability")+
theme(
text = element_text(size = 16),  # Increase all text size
axis.title = element_text(size = 18),  # Increase axis titles
axis.text = element_text(size = 14),  # Increase axis labels
legend.title = element_text(size = 16),  # Increase legend title size
legend.text = element_text(size = 14)  # Increase legend text size
)
